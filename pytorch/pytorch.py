import torch


def Calculate_Q(chromosome, whole_size, num_node, num_edge, adjacent_array):
    """
    Calculate the modularity from the genome matrix and chromosome vector.

    Args:
        chromosome (list): All chromosomes in the population.
        whole_size (int): The total number of the original and new individuals.
        num_node (int): The number of nodes in the network.
        num_edge (int): The number of edges in the network.
        adjacent_array (torch.Tensor): The adjacent matrix of the network.

    Returns:
        list: All chromosomes in the population with updated fitness values.
    """
    # Transform the genome matrix into the vector whose elements represent the community to which a node belongs.
    node_chrom = change(chromosome, whole_size, num_node)

    for pop_id in range(whole_size):
        num_cluster = torch.max(node_chrom[pop_id]).item()
        e = torch.zeros(num_cluster)
        a = torch.zeros(num_cluster)

        for j in range(num_cluster):
            cluster_id = j
            nodes_in_cluster = torch.where(node_chrom[pop_id] == cluster_id)[
                0
            ]  # Find the nodes within the same community.
            L = len(nodes_in_cluster)  # L - the number of nodes in a community.

            for k in range(L):
                for m in range(num_node):
                    if (
                        adjacent_array[nodes_in_cluster[k], m] == 1
                    ):  # Find the node's neighbors.
                        # Check if nodes are clustered into the same community.
                        if chromosome[pop_id].genome[nodes_in_cluster[k], m] == 1:
                            e[cluster_id] += 1
                        else:
                            a[cluster_id] += 1

        e /= 2
        a /= 2
        a += e
        e /= num_edge
        a = (a / num_edge) ** 2
        Q = 0

        for n in range(num_cluster):
            Q += e[n] - a[n]

        chromosome[pop_id].fitness_1 = (
            Q  # Modularity calculated from the genome matrix.
        )
        chromosome[pop_id].clusters = node_chrom[pop_id]  # The clustering result.
        chromosome[pop_id].fitness_2 = Modularity(
            adjacent_array, chromosome[pop_id].clusters
        )  # Modularity.

    return chromosome


def CreatEdgeList(adjacent_array):
    """
    Create the edge list from the adjacent matrix.

    Args:
        adjacent_array (torch.Tensor): The adjacent matrix of the network.

    Returns:
        torch.Tensor: The edge list of the network.
    """
    x, y = torch.where(adjacent_array)
    l = len(x)
    edge_begin_end = torch.zeros((l // 2, 3), dtype=torch.long)
    j = 0

    for i in range(l):
        if x[i] > y[i]:
            edge_begin_end[j, 0] = j
            edge_begin_end[j, 1] = x[i]
            edge_begin_end[j, 2] = y[i]
            j += 1

    return edge_begin_end


def Crossover(chromosome, selected_pop_id, node_num):
    """
    Perform crossover on a pair of selected individuals to generate 2 children individuals.

    Args:
        chromosome (list): All chromosomes in the population.
        selected_pop_id (list): The indices of the selected individuals for crossover.
        node_num (int): The number of nodes in the network.

    Returns:
        tuple: Two children chromosomes generated by crossover.
    """
    child_chromosome_1 = {
        "genome": None,
        "clusters": None,
        "fitness_1": None,
        "fitness_2": None,
    }
    child_chromosome_2 = {
        "genome": None,
        "clusters": None,
        "fitness_1": None,
        "fitness_2": None,
    }
    cross_over_population_id = selected_pop_id
    cross_over_count = torch.randint(1, node_num // 2 + 1, (1,)).item()
    cross_over_node_id = torch.randint(0, node_num, (cross_over_count,))

    # Two-way crossover.
    temp1_part = chromosome[cross_over_population_id[0]].genome[cross_over_node_id]
    temp2_part = chromosome[cross_over_population_id[1]].genome[cross_over_node_id]
    temp1_whole = chromosome[cross_over_population_id[0]].genome.clone()
    temp2_whole = chromosome[cross_over_population_id[1]].genome.clone()
    temp1_whole[cross_over_node_id] = temp2_part
    temp1_whole[:, cross_over_node_id] = temp2_part.t()
    temp2_whole[cross_over_node_id] = temp1_part
    temp2_whole[:, cross_over_node_id] = temp1_part.t()

    child_chromosome_1["genome"] = temp1_whole  # Child 1.
    child_chromosome_2["genome"] = temp2_whole  # Child 2.

    return child_chromosome_1, child_chromosome_2


import torch


def Migration(chromosome, node_num, adj_mat, p_migration):
    """
    Execute migration on a chromosome.

    Args:
        chromosome (dict): The chromosome to perform migration on.
        node_num (int): The number of nodes in the network.
        adj_mat (torch.Tensor): The adjacent matrix of the network.
        p_migration (float): The migration rate.

    Returns:
        dict: The chromosome after migration.
    """
    # The nodes' communities in a vector.
    clu_assignment = change(chromosome, 1, node_num).squeeze()
    # Find the nodes in each community.
    clu_num = torch.max(clu_assignment).item()
    index = [torch.where(clu_assignment == i)[0] for i in range(1, clu_num + 1)]

    for j in range(clu_num):
        num_node_in_clu = len(index[j])  # The number of nodes in community j.
        k = 0

        while k < num_node_in_clu and num_node_in_clu != 0:
            S = adj_mat[index[j]][:, index[j]]
            sum_inter = []
            neighbor_cluster = []
            node_id = index[j][k]
            sum_intra = torch.sum(
                S[k]
            )  # The total number of edges intra-connecting the node.
            neighbor_nodes = torch.where(adj_mat[node_id] == 1)[
                0
            ]  # The neighbors in the network.
            neighbor_cluster = torch.unique(
                clu_assignment[neighbor_nodes]
            )  # Find the community of each neighbor.
            neighbor_cluster = neighbor_cluster[neighbor_cluster != j + 1]
            len_neighbor_cluster = len(neighbor_cluster)

            if len_neighbor_cluster == 0:
                k += 1
            else:  # len > 0
                sum_inter = torch.zeros((len_neighbor_cluster, 2), dtype=torch.long)
                sum_inter[:, 0] = neighbor_cluster - 1  # The community id.
                # The edges connecting the nodes in other communities.
                for l in range(len_neighbor_cluster):
                    neighbor_clu_id = neighbor_cluster[l].item()
                    sum_inter[l, 1] = torch.sum(
                        adj_mat[index[neighbor_clu_id - 1], node_id]
                    )

                max_inter = torch.max(sum_inter[:, 1]).item()
                temp_id = torch.where(sum_inter[:, 1] == max_inter)[0]
                # Randomly select one of candidate communities.
                max_inter_id = sum_inter[
                    temp_id[torch.randint(len(temp_id), (1,))], 0
                ].item()

                # Migration on 3 kinds of nodes.
                if sum_intra < max_inter:  # For a weakly-neighbor node.
                    # Inter-connected to the nodes which is originally intra-connected.
                    orgn_edge = torch.where(chromosome["genome"][node_id] == 1)[
                        0
                    ]  # The original intra-connected nodes.
                    chromosome["genome"][orgn_edge, node_id] = -1
                    chromosome["genome"][node_id, orgn_edge] = -1
                    # Choose a candidate community to join in.
                    a = torch.where(
                        chromosome["genome"][index[max_inter_id], node_id] == -1
                    )[0]
                    new_edge = index[max_inter_id][a]
                    # Randomly select nodes in the selected community to be intra-connect.
                    num_selected_edge = torch.randint(1, len(new_edge) + 1, (1,)).item()
                    selected_edge_sort = torch.randperm(len(new_edge))[
                        :num_selected_edge
                    ]
                    selected_edge = new_edge[selected_edge_sort]
                    chromosome["genome"][selected_edge, node_id] = 1
                    chromosome["genome"][node_id, selected_edge] = 1

                    # Update nodes' communities.
                    clu_assignment[node_id] = max_inter_id + 1
                    # Updates the nodes in each community.
                    index[j] = index[j][index[j] != node_id]  # Remove.
                    index[max_inter_id] = torch.cat(
                        (index[max_inter_id], torch.tensor([node_id]))
                    )  # Add.
                    num_node_in_clu -= 1

                if sum_intra == max_inter:  # For a neutrally-neighbor node.
                    if (
                        torch.rand(1).item() > p_migration
                    ):  # Choose a candidate community to join in.
                        orgn_edge = torch.where(chromosome["genome"][node_id] == 1)[
                            0
                        ]  # Intra-connected edges.
                        chromosome["genome"][orgn_edge, node_id] = -1
                        chromosome["genome"][node_id, orgn_edge] = -1
                        a = chromosome["genome"][index[max_inter_id], node_id] == -1
                        # Intra-connected to nodes in the selected candidate community.
                        new_edge = index[max_inter_id][a]
                        chromosome["genome"][new_edge, node_id] = 1
                        chromosome["genome"][node_id, new_edge] = 1
                        # Update nodes' communities.
                        clu_assignment[node_id] = max_inter_id + 1
                        # Updates the nodes in each community.
                        index[j] = index[j][index[j] != node_id]  # Remove.
                        index[max_inter_id] = torch.cat(
                            (index[max_inter_id], torch.tensor([node_id]))
                        )  # Add.
                        num_node_in_clu -= 1

                if sum_intra > max_inter:  # For a strongly-neighbor node.
                    k += 1

    return chromosome


import torch


def Modularity(adj_mat, clu_assignment):
    """
    Calculate the modularity of a given community structure.

    Args:
        adj_mat (torch.Tensor): The adjacent matrix of the network.
        clu_assignment (torch.Tensor): The community assignment vector.

    Returns:
        float: The modularity value.
    """
    n = torch.max(clu_assignment).item()  # The number of clusters.
    L = torch.sum(adj_mat) / 2  # The total number of edges in the network.
    Q = 0

    for i in range(1, n + 1):
        index = torch.where(clu_assignment == i)[0]
        S = adj_mat[index][:, index]
        li = torch.sum(S) / 2
        di = torch.sum(torch.sum(adj_mat[index], dim=1))
        Q += li - (di**2) / (4 * L)

    return Q / L


import torch


def Mutation(child_chromosome, mutation_rate, num_edge, edge_begin_end):
    """
    Execute mutation on a chromosome.

    Args:
        child_chromosome (dict): The chromosome to perform mutation on.
        mutation_rate (float): The mutation rate.
        num_edge (int): The number of edges in the network.
        edge_begin_end (torch.Tensor): The edge list of the network.

    Returns:
        dict: The chromosome after mutation.
    """
    num_mutation = int(num_edge * mutation_rate)  # The number of mutated edges.

    for _ in range(num_mutation):
        mutation_edge_id = torch.randint(0, num_edge, (1,)).item()
        node1, node2 = (
            edge_begin_end[mutation_edge_id, 1],
            edge_begin_end[mutation_edge_id, 2],
        )
        child_chromosome["genome"][node1, node2] *= -1
        child_chromosome["genome"][node2, node1] *= -1

    return child_chromosome


import torch


def NMI(A, B):
    """
    Calculate the normalized mutual information (NMI) between two partitions.

    Args:
        A (torch.Tensor): The first partition.
        B (torch.Tensor): The second partition.

    Returns:
        float: The NMI value.
    """
    if len(A) != len(B):
        raise ValueError("The lengths of A and B must be equal.")

    total = len(A)
    A_ids = torch.unique(A)
    B_ids = torch.unique(B)
    # Mutual information.
    MI = 0

    for idA in A_ids:
        for idB in B_ids:
            idAOccur = torch.where(A == idA)[0]
            idBOccur = torch.where(B == idB)[0]
            idABOccur = torch.tensor([i for i in idAOccur if i in idBOccur])

            px = len(idAOccur) / total
            py = len(idBOccur) / total
            pxy = len(idABOccur) / total

            MI += pxy * torch.log2(
                pxy / (px * py) + 1e-9
            )  # eps: the smallest positive number.

    # Normalized mutual information.
    Hx = 0  # Entropies.
    for idA in A_ids:
        idAOccurCount = len(torch.where(A == idA)[0])
        Hx -= (idAOccurCount / total) * torch.log2(idAOccurCount / total + 1e-9)

    Hy = 0  # Entropies.
    for idB in B_ids:
        idBOccurCount = len(torch.where(B == idB)[0])
        Hy -= (idBOccurCount / total) * torch.log2(idBOccurCount / total + 1e-9)

    return 2 * MI / (Hx + Hy)


import torch


def PGLP(node_num, el, iters):
    """
    Population Generation via Label Propagation (PGLP).

    Args:
        node_num (int): The number of nodes in the network.
        el (list): The edges list of the network.
        iters (int): The number of iterations for label propagation.

    Returns:
        torch.Tensor: The population generated by PGLP.
    """
    x = torch.arange(node_num)
    x = perturbation(x)

    for _ in range(iters):
        temp_x = x.clone()

        for j in range(node_num):
            nb_labels = temp_x[el[j]["e"]]
            nb_size = el[j]["n"]

            if nb_size > 0:
                t = torch.bincount(nb_labels)
                max_nb_labels = torch.where(t == torch.max(t))[0]
                x[j] = max_nb_labels[torch.randint(len(max_nb_labels), (1,))].item()

    return sorting(x)


def perturbation(x):
    """
    Perturb the order of elements in a tensor.

    Args:
        x (torch.Tensor): The tensor to be perturbed.

    Returns:
        torch.Tensor: The perturbed tensor.
    """
    n = len(x)
    i = n - 1

    while i > 0:
        index = torch.randint(0, n, (1,)).item()
        temp = x[i].clone()
        x[i] = x[index]
        x[index] = temp
        i -= 1

    return x


def sorting(X):
    """
    Sort the elements in a tensor.

    Args:
        X (torch.Tensor): The tensor to be sorted.

    Returns:
        torch.Tensor: The sorted tensor.
    """
    flag = 0
    tempX = X.clone()

    for i in range(len(X)):
        if tempX[i] != -1:
            for j in range(i + 1, len(X)):
                if tempX[i] == tempX[j]:
                    X[j] = flag
                    tempX[j] = -1

            tempX[i] = -1
            X[i] = flag
            flag += 1

    return X


def Sort_Q(chromosome, whole_size, signal):
    """
    Sort the chromosomes by modularity.

    Args:
        chromosome (list): All chromosomes in the population.
        whole_size (int): The total number of the original and new individuals.
        signal (int): The signal indicating the sorting criterion.
        1: sort by the modularity value calculated from the adjacent matrix;
        2: sort by the modularity values calculated from the chromosome vector.

    Returns:
        list: The sorted chromosomes.
    """
    if signal == 1:
        chromosome.sort(key=lambda x: x["fitness_1"], reverse=True)
    elif signal == 2:
        chromosome.sort(key=lambda x: (x["fitness_2"], x["fitness_1"]), reverse=True)

    return chromosome


import torch


def change(chromosome, pop_size, num_node):
    """
    Transform the genome matrix into the vector whose elements represent the community to which a node belongs.

    Args:
        chromosome (list): All chromosomes in the population.
        pop_size (int): The population size.
        num_node (int): The number of nodes in the network.

    Returns:
        torch.Tensor: A matrix where each row represents the clustering of an individual,
            which displays the community to which each node belongs.
    """
    node_chrom = torch.zeros((pop_size, num_node), dtype=torch.long)

    for population_id in range(pop_size):
        flag = torch.zeros(num_node, dtype=torch.long)
        cluster_id = 1
        node_chrom[population_id, 0] = cluster_id

        for row_id in range(num_node):
            if flag[row_id] == 0:
                flag[row_id] = 1
                node_chrom[population_id], flag = row_change(
                    chromosome[population_id]["genome"],
                    node_chrom[population_id],
                    flag,
                    population_id,
                    num_node,
                    cluster_id,
                    row_id,
                )
                cluster_id += 1

    return node_chrom


def row_change(genome, node_chrom, flag, population_id, node_num, cluster_id, row_id):
    """
    Auxiliary function for change function.

    Args:
        genome (torch.Tensor): The genome matrix.
        node_chrom (torch.Tensor): The node-community vector.
        flag (torch.Tensor): The flag vector indicating visited nodes.
        population_id (int): The ID of the population.
        node_num (int): The number of nodes in the network.
        cluster_id (int): The current cluster ID.
        row_id (int): The current row index.

    Returns:
        tuple: The updated node_chrom and flag.
    """
    node_chrom[row_id] = cluster_id

    for colum_id in range(node_num):
        if genome[row_id, colum_id] == 1 and flag[colum_id] == 0:
            flag[colum_id] = 1
            node_chrom, flag = row_change(
                genome, node_chrom, flag, population_id, node_num, cluster_id, colum_id
            )

    return node_chrom, flag


import torch


def decomposedFitness(weight, objectives, idealpoint):
    """
    Calculate the decomposed fitness value based on weights and objectives.

    Args:
        weight (torch.Tensor): The weight vector.
        objectives (torch.Tensor): The objective values.
        idealpoint (torch.Tensor): The ideal point.

    Returns:
        float: The decomposed fitness value.
    """
    weight[weight == 0] = 1e-5  # Ensure weight > 0.
    part2 = torch.abs(objectives - idealpoint)
    return torch.max(weight * part2)


import torch


def edges_list(A, V):
    """
    Generate the edges list for each node.

    Args:
        A (torch.Tensor): The adjacent matrix of the network.
        V (int): The number of nodes in the network.

    Returns:
        list: The edges list for each node.
    """
    et = []

    for i in range(V):
        et.append({"e": [], "n": 0})
        for j in range(V):
            if A[i, j] == 1:
                et[i]["e"].append(j)
                et[i]["n"] += 1

    return et


import torch


def evaluate_objectives(
    chromosome, whole_size, node_num, edge_num, adjacent_array, pre_cluster
):
    """
    Calculate the modularity from the genome matrix and chromosome vector, respectively.

    Args:
        chromosome (list): All chromosomes in the population.
        whole_size (int): The total number of the original and new individuals.
        node_num (int): The number of nodes in the network.
        edge_num (int): The number of edges in the network.
        adjacent_array (torch.Tensor): The adjacent matrix of the network.
        pre_cluster (torch.Tensor): The clustering result at the previous time step.

    Returns:
        list: All chromosomes in the population with updated fitness values.
    """
    # Transform the genome matrix into the vector whose elements represent the community to which a node belongs.
    node_chrom = change(chromosome, whole_size, node_num)

    for pop_id in range(whole_size):
        clusters_num = torch.max(node_chrom[pop_id]).item()
        e = torch.zeros(clusters_num)
        a = torch.zeros(clusters_num)

        for j in range(clusters_num):
            cluster_id = j
            nodes_in_cluster = torch.where(node_chrom[pop_id] == cluster_id)[
                0
            ]  # Find the nodes within the same community.
            L = len(nodes_in_cluster)  # L - the number of nodes in a community.

            for k in range(L):
                for m in range(node_num):
                    if (
                        adjacent_array[nodes_in_cluster[k], m] == 1
                    ):  # Find the node's neighbors.
                        # Check if nodes are clustered into the same community.
                        if chromosome[pop_id]["genome"][nodes_in_cluster[k], m] == 1:
                            e[cluster_id] += 1
                        else:
                            a[cluster_id] += 1

        e /= 2
        a /= 2
        a += e
        e /= edge_num
        a = (a / edge_num) ** 2
        Q = torch.sum(e - a)

        chromosome[pop_id]["fitness_1"] = torch.tensor(
            [-Q]
        )  # (-) modularity calculated from the genome matrix.
        chromosome[pop_id]["fitness_1"] = torch.cat(
            (
                chromosome[pop_id]["fitness_1"],
                torch.tensor([-NMI(node_chrom[pop_id], pre_cluster)]),
            )
        )  # Temporal smoothness.
        chromosome[pop_id]["clusters"] = node_chrom[pop_id]  # The clustering result.
        chromosome[pop_id]["fitness_2"] = torch.tensor(
            [-Modularity(adjacent_array, chromosome[pop_id]["clusters"])]
        )  # Modularity.

    return chromosome


def init_weight(popsize, niche):
    """
    Initialize weights and neighbors.

    Args:
        popsize (int): The population size.
        niche (int): The size of the neighborhood.

    Returns:
        tuple: The weights and neighbors.
    """
    weights = torch.zeros((popsize, 2))

    for i in range(popsize):
        weights[i, 0] = i / (popsize - 1)
        weights[i, 1] = (popsize - i - 1) / (popsize - 1)

    # Set up the neighborhood.
    leng = weights.size(0)
    distanceMatrix = torch.zeros((leng, leng))

    for i in range(leng):
        for j in range(i + 1, leng):
            A = weights[i]
            B = weights[j]
            distanceMatrix[i, j] = torch.dot(A - B, A - B)
            distanceMatrix[j, i] = distanceMatrix[i, j]

        sindex = torch.argsort(distanceMatrix[i])
        neighbors = sindex[:niche]

    return weights, neighbors


import torch
import time


def DECS_1(
    adjacent_array, maxgen, pop_size, p_mutation, p_migration, p_mu_mi, PGLP_iter
):
    """
    Detect the community structure at the 1st time step.

    Args:
        adjacent_array (torch.Tensor): The adjacent matrix.
        maxgen (int): The maximum number of iterations.
        pop_size (int): The population size.
        p_mutation (float): The mutation rate.
        p_migration (float): The migration rate.
        p_mu_mi (float): The parameter to organize the execution of mutation and migration.
        PGLP_iter (int): The number of iterations in PGLP.

    Returns:
        tuple: (modularity, chromosomes, division, running_time)
            - modularity (float): The modularity of the detected community structure.
            - chromosomes (list): The chromosomes in the population.
            - division (torch.Tensor): The detected community structure.
            - running_time (float): The running time of the function.
    """
    if not torch.equal(adjacent_array, adjacent_array.t()):
        adjacent_array = adjacent_array + adjacent_array.t()

    # Set the diagonal elements of an adjacent matrix to be 0.
    row = torch.diag(adjacent_array).nonzero().squeeze()
    adjacent_array[row, row] = 0

    edge_begin_end = CreatEdgeList(adjacent_array)
    num_node = adjacent_array.size(1)
    num_edge = torch.sum(adjacent_array) // 2
    children_proportion = (
        1  # The proportion of the number of child individuals to pop_size.
    )
    DynQ = torch.zeros(maxgen, 1)  # Modularity calculated from the adjacent matrix.
    whole_size = int(torch.ceil((1 + children_proportion) * pop_size))

    start_time = time.time()
    chromosome = Initial_PGLP(pop_size, adjacent_array, num_node, PGLP_iter)
    chromosome = Calculate_Q(chromosome, pop_size, num_node, num_edge, adjacent_array)
    chromosome = Sort_Q(chromosome, pop_size, 1)

    DynQ[0, 0] = chromosome[0]["fitness_1"]
    print(
        f"time_stamp=1; 0 : Q_genome={DynQ[0, 0]:.4f}; Modularity={chromosome[0]['fitness_2']:.4f}"
    )

    for i in range(1, maxgen):  # The i-th iteration.
        # Generate offspring.
        selected_pop_id = []
        for j in range(pop_size, whole_size, 2):
            # Select 2 different individuals from population to crossover.
            while len(selected_pop_id) == 0 or selected_pop_id[0] == selected_pop_id[1]:
                selected_pop_id = torch.randint(pop_size, (2,)).tolist()
            # Crossover.
            chromosome[j], chromosome[j + 1] = Crossover(
                chromosome, selected_pop_id, num_node
            )

        for pop_id in range(pop_size, whole_size):
            if torch.rand(1) < p_mu_mi:
                # Mutation.
                chromosome[pop_id] = Mutation(
                    chromosome[pop_id], p_mutation, num_edge, edge_begin_end
                )
            else:
                # Migration.
                chromosome[pop_id] = Migration(
                    chromosome[pop_id], num_node, adjacent_array, p_migration
                )

        chromosome = Calculate_Q(
            chromosome, whole_size, num_node, num_edge, adjacent_array
        )
        chromosome = Sort_Q(chromosome, whole_size, 1)  # Sort chromosomes by Q.
        chromosome = chromosome[
            :100
        ]  # Clear up chromosomes with low modularity values.
        DynQ[i, 0] = chromosome[0]["fitness_1"]
        print(
            f"time_stamp=1; {i} : Q_genome={DynQ[i, 0]:.4f}; Modularity={chromosome[0]['fitness_2']:.4f}"
        )

    Division = chromosome[0]["clusters"]
    Mod = Modularity(adjacent_array, chromosome[0]["clusters"])
    running_time = time.time() - start_time

    return Mod, chromosome, Division, running_time


import torch
import time


def DECS_2(
    adjacent_array,
    maxgen,
    pop_size,
    p_mutation,
    p_migration,
    p_mu_mi,
    num_neighbor,
    pre_Result,
    PGLP_iter,
):
    """
    Detect the community structure at the time step.

    Args:
        adjacent_array (torch.Tensor): The adjacent matrix.
        maxgen (int): The maximum number of iterations.
        pop_size (int): The population size.
        p_mutation (float): The mutation rate.
        p_migration (float): The migration rate.
        p_mu_mi (float): The parameter to organize the execution of mutation and migration.
        num_neighbor (int): The neighbor size for each subproblem in decomposition-based multi-objective optimization.
        pre_Result (torch.Tensor): The detected community structure at the last time step.
        PGLP_iter (int): The number of iterations in PGLP.

    Returns:
        tuple: (modularity, chromosomes, division, running_time)
            - modularity (float): The modularity of the detected community structure.
            - chromosomes (list): The chromosomes in the population.
            - division (torch.Tensor): The detected community structure.
            - running_time (float): The running time of the function.
    """
    global idealp, weights, neighbors

    if not torch.equal(adjacent_array, adjacent_array.t()):
        adjacent_array = adjacent_array + adjacent_array.t()

    # Set the diagonal elements of an adjacent matrix to be 0.
    row = torch.diag(adjacent_array).nonzero().squeeze()
    adjacent_array[row, row] = 0

    edge_begin_end = CreatEdgeList(adjacent_array)
    num_node = adjacent_array.size(1)  # The number of nodes.
    num_edge = torch.sum(adjacent_array) // 2  # The number of edges.

    child_chromosome = [
        {"genome": None, "clusters": None, "fitness_1": None, "fitness_2": None}
        for _ in range(pop_size)
    ]

    start_time = time.time()
    EP = []  # Non-dominated solution set.
    idealp = torch.full((1, 2), -float("inf"))  # The reference point (z1, z2).
    weights, neighbors = init_weight(
        pop_size, num_neighbor
    )  # Find neighbor solutions to each subproblem.
    chromosome = Initial_PGLP(pop_size, adjacent_array, num_node, PGLP_iter)
    chromosome = evaluate_objectives(
        chromosome, pop_size, num_node, num_edge, adjacent_array, pre_Result
    )  # Calculate the values of modularity and NMI.

    f = torch.tensor([c["fitness_1"] for c in chromosome])
    idealp = torch.min(
        f, dim=0
    ).values  # Find the reference point after initialization.

    for t in range(1, maxgen + 1):  # The t-th iteration.
        for pop_id in range(1, pop_size + 1, 2):
            selected_neighbor_id = []
            while (
                len(selected_neighbor_id) == 0
                or selected_neighbor_id[0] == selected_neighbor_id[1]
            ):
                selected_neighbor_id = torch.randint(1, num_neighbor + 1, (2,)).tolist()

            selected_pop_id = neighbors[
                pop_id - 1, [i - 1 for i in selected_neighbor_id]
            ]
            child_chromosome[pop_id - 1], child_chromosome[pop_id] = Crossover(
                chromosome, selected_pop_id, num_node
            )  # Crossover.

            for m in range(2):
                if torch.rand(1) < p_mu_mi:
                    child_chromosome[pop_id - 1 + m] = Mutation(
                        child_chromosome[pop_id - 1 + m],
                        p_mutation,
                        num_edge,
                        edge_begin_end,
                    )  # Mutate.
                else:
                    child_chromosome[pop_id - 1 + m] = Migration(
                        child_chromosome[pop_id - 1 + m],
                        num_node,
                        adjacent_array,
                        p_migration,
                    )  # Migrate.

                child_chromosome[pop_id - 1 + m] = evaluate_objectives(
                    child_chromosome[pop_id - 1 + m],
                    1,
                    num_node,
                    num_edge,
                    adjacent_array,
                    pre_Result,
                )  # Calculate the fitness values of clustering results.

                for k in neighbors[pop_id - 1 + m]:
                    child_fit = decomposedFitness(
                        weights[k],
                        child_chromosome[pop_id - 1 + m]["fitness_1"],
                        idealp,
                    )
                    gbest_fit = decomposedFitness(
                        weights[k], chromosome[k]["fitness_1"], idealp
                    )

                    if child_fit < gbest_fit:
                        chromosome[k]["genome"] = child_chromosome[pop_id - 1 + m][
                            "genome"
                        ]
                        chromosome[k]["clusters"] = child_chromosome[pop_id - 1 + m][
                            "clusters"
                        ]
                        chromosome[k]["fitness_1"] = child_chromosome[pop_id - 1 + m][
                            "fitness_1"
                        ]
                        chromosome[k]["fitness_2"] = child_chromosome[pop_id - 1 + m][
                            "fitness_2"
                        ]

        for pop_id in range(pop_size):
            if not EP:
                EP.append(chromosome[pop_id])
            else:
                isDominate = False
                isExist = False
                rmindex = []

                for k in range(len(EP)):
                    if torch.equal(chromosome[pop_id]["clusters"], EP[k]["clusters"]):
                        isExist = True

                    if dominate(chromosome[pop_id], EP[k]):
                        rmindex.append(k)
                    elif dominate(EP[k], chromosome[pop_id]):
                        isDominate = True

                EP = [EP[i] for i in range(len(EP)) if i not in rmindex]

                if not isDominate and not isExist:
                    EP.append(chromosome[pop_id])

            idealp = torch.min(
                torch.cat((child_chromosome[pop_id]["fitness_1"].unsqueeze(0), idealp)),
                dim=0,
            ).values

    Modularity = torch.tensor([abs(front["fitness_2"][0]) for front in EP])
    index = torch.argmax(Modularity)
    Division = EP[index][
        "clusters"
    ]  # Restore the optimal solution, i.e., the network division with high quality.
    Mod = -EP[index]["fitness_2"][0]  # Decoded positive "+" modularity.
    running_time = time.time() - start_time

    return Mod, chromosome, Division, running_time


import torch
from itertools import combinations


def Initial_PGLP(population_size, adj_mat, node_num, PGLP_iter):
    """
    Generate the initial population by PGLP.

    Args:
        population_size (int): The size of the population.
        adj_mat (torch.Tensor): The adjacency matrix of the graph.
        node_num (int): The number of nodes in the graph.
        PGLP_iter (int): The number of iterations for PGLP.

    Returns:
        list: The list of initial chromosomes.
    """
    chromosome = [
        {"genome": None, "clusters": None, "fitness_1": None, "fitness_2": None}
       for _ in range(population_size)
    ]
    pop_X = torch.zeros((population_size, node_num), dtype=torch.int64)

    for population_id in range(population_size):
        edgeslist = edges_list(adj_mat, node_num)
        pop_X[population_id] = PGLP(node_num, edgeslist, PGLP_iter)
        temp = adj_mat.clone()

        for cluster_id in range(1, torch.max(pop_X[population_id]).item() + 1):
            node_id = (pop_X[population_id] == cluster_id).nonzero().squeeze()

            if len(node_id) > 1:
                pl = torch.tensor(
                    list(combinations(node_id.tolist(), 2)), dtype=torch.int64
                )

                for i in range(pl.size(0)):
                    temp[pl[i, 0], pl[i, 1]] = -adj_mat[pl[i, 0], pl[i, 1]]
                    temp[pl[i, 1], pl[i, 0]] = -adj_mat[pl[i, 1], pl[i, 0]]

        chromosome[population_id]["genome"] = -temp
        chromosome[population_id]["clusters"] = 0
        chromosome[population_id]["fitness_1"] = 0.0
        chromosome[population_id]["fitness_2"] = 0.0

    return chromosome


def dominate(x, y):
    """
    Check if solution x dominates solution y.

    Args:
        x (dict or torch.Tensor): The first solution.
        y (dict or torch.Tensor): The second solution.

    Returns:
        bool: True if x dominates y, False otherwise.
    """
    if isinstance(x, dict) and "fitness_1" in x:
        x = x["fitness_1"]
    if isinstance(y, dict) and "fitness_1" in y:
        y = y["fitness_1"]

    return torch.all(x <= y) and torch.any(x < y)
